<!DOCTYPE html>
<html lang="en-us"><head><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">Kubernetes | My Blog</title>
<meta property="og:title" content="Kubernetes | My Blog" />
<meta name="twitter:title" content="Kubernetes | My Blog" />
<meta itemprop="name" content="Kubernetes | My Blog" />
<meta name="application-name" content="Kubernetes | My Blog" />
<meta property="og:site_name" content="" />

<meta name="description" content="">
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />

<meta property="og:locale" content="en-us" />
<meta name="language" content="en-us" />



  <meta itemprop="image" content="https://programmerraja.github.io/blog" />
  <meta property="og:image" content="https://programmerraja.github.io/blog" />
  <meta name="twitter:image" content="https://programmerraja.github.io/blog" />
  <meta name="twitter:image:src" content="https://programmerraja.github.io/blog" />





<meta name="generator" content="Hugo 0.121.1">

    

    <link rel="canonical" href="https://programmerraja.github.io/blog/notes/2024/kubernetes/">
    <link href="/blog/style.min.a331e196842d6df0db458dbc74b8cb9d3f93dc2a4203f1ef625a27c46f956787.css" rel="stylesheet">
    <link href="/blog/code-highlight.min.cef708dbb43e89c2c3d5d13ad8e529de1b26ba57d3fda7293efd1cfe88a8c6fb.css" rel="stylesheet">

    
    <link rel="apple-touch-icon" sizes="180x180" href="/blog/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/blog/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/blog/icons/favicon-16x16.png">
    <link rel="mask-icon" href="/blog/icons/safari-pinned-tab.svg">
    <link rel="shortcut icon" href="/blog/favicon.ico">




<link rel="manifest" href="https://programmerraja.github.io/blog/site.webmanifest">

<meta name="msapplication-config" content="/blog/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    
    <link rel="icon" type="image/svg+xml" href="/blog/icons/favicon.svg">

    
    </head>
<body data-theme = "" class="notransition">

<script src="/blog/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js" integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="https://programmerraja.github.io/blog/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title></title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/blog/post/">
                        Posts
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/blog/resources/">
                        Resources
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/blog/notes/">
                        Notes
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="https://programmerraja.github.io/">
                        Portfolio
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">Kubernetes</h1>
                
                
                <div class="post-meta">
                    <time datetime="2024-01-01T08:19:32&#43;05:30" itemprop="datePublished"> Jan 1, 2024 </time>
                </div>
                
            </header>
                
                
                <details class="toc" ZgotmplZ>
                    <summary><b>Table of Contents</b></summary>
                    <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#kubernetes-is-two-things">Kubernetes is two things</a></li>
        <li><a href="#kubernetes-cluster">Kubernetes cluster</a></li>
        <li><a href="#nodes">Nodes</a></li>
        <li><a href="#kubernetes-dns">Kubernetes DNS</a></li>
        <li><a href="#pods-its-just-a-sandbox-for-hosting-containers">Pods (it’s just a sandbox for hosting containers.)</a></li>
        <li><a href="#replicaset">ReplicaSet</a></li>
        <li><a href="#deployments">Deployments</a></li>
        <li><a href="#services">Services</a></li>
        <li><a href="#service-monitor">Service Monitor</a></li>
        <li><a href="#kubernetes-storage">Kubernetes storage</a></li>
        <li><a href="#config-maps">Config Maps</a></li>
        <li><a href="#secretes">Secretes</a></li>
        <li><a href="#statefulsets">StatefulSets</a></li>
        <li><a href="#without-statefulsets">Without StatefulSets</a></li>
        <li><a href="#with-statefulsets">With StatefulSets</a></li>
        <li><a href="#kubectl">Kubectl</a></li>
        <li><a href="#resources">Resources</a></li>
        <li><a href="#products">Products</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </details>
                <div class="page-content">
                <h3 id="kubernetes-is-two-things">Kubernetes is two things</h3>
<ul>
<li>A cluster for running applications</li>
<li>An orchestrator of cloud-native microservices apps</li>
</ul>
<h3 id="kubernetes-cluster">Kubernetes cluster</h3>
<p>A Kubernetes cluster contains six main components:</p>
<ol>
<li><code>API server:</code> Exposes a REST interface to all Kubernetes resources. Serves as the front end of the Kubernetes control plane.</li>
<li><code>Scheduler</code>: Places containers according to resource requirements and metrics. Makes note of Pods with no assigned node, and selects nodes for them to run on.</li>
<li><code>Controller manager</code>: Runs controller processes and reconciles the cluster’s actual state with its desired specifications. Manages controllers such as node controllers, endpoints controllers and replication controllers.</li>
<li><code>Kubelet</code>: Ensures that containers are running in a Pod by interacting with the Docker engine , the default program for creating and managing containers. Takes a set of provided PodSpecs and ensures that their corresponding containers are fully operational.</li>
<li><code>Kube-proxy</code>: Manages network connectivity and maintains network rules across nodes. Implements the Kubernetes Service concept across every node in a given cluster.</li>
<li><code>Etcd:</code> Stores all cluster data like how many pod and there replica count . Consistent and highly available Kubernetes backing store.</li>
</ol>
<p><strong>Ways to create kubernetes cluster</strong></p>
<ul>
<li><a href="https://kind.sigs.k8s.io/">Kind</a> [Fast and easy]</li>
<li>Minikube</li>
<li>microk8s</li>
<li>kudeadm</li>
<li>Google cloud platform</li>
<li>AWS</li>
<li>Azure</li>
</ul>
<h3 id="nodes">Nodes</h3>
<p>Nodes are the workers of a Kubernetes cluster. At a high-level they do three things:</p>
<ol>
<li>
<p>Watch the API Server for new work assignments</p>
</li>
<li>
<p>Execute new work assignments</p>
</li>
<li>
<p>Report back to the control plane (via the API server)</p>
</li>
</ol>
<p>Nodes contain</p>
<ul>
<li>
<p><strong>Kubelet</strong> →When you join a new node to a cluster, the process installs kubelet onto the node. The kubelet is then responsible for registering the node with the cluster. Registration effectively pools the node’s CPU, memory, and storage into the wider cluster pool. One of the main jobs of the kubelet is to watch the API server for new work assignments. Any time it sees one, it executes the task and maintains a reporting channel back to the control plane.</p>
</li>
<li>
<p><strong>Container runtime</strong> →The Kubelet needs a container runtime to perform container-related tasks things like pulling images and starting and stopping containers.There are lots of container runtimes available for Kubernetes. One popular example is cri-containerd .</p>
</li>
<li>
<p><strong>Kube-proxy</strong> →This runs on every node in the cluster and is responsible for local cluster networking. For example, it makes sure each node gets its own unique IP address, and implements local IPTABLES or IPVS rules to handle routing and load-balancing of traffic on the Pod network.</p>
</li>
</ul>
<h3 id="kubernetes-dns">Kubernetes DNS</h3>
<p>Every Pod on the cluster, meaning all containers and Pods know how to find it. Every new service is automatically registered with the cluster’s DNS so that all components in the cluster can find every Service by name. Some other components that are registered with the cluster DNS are StatefulSets and the individual Pods that a StatefulSet manages.Cluster DNS is based on CoreDNS (<a href="https://coredns.io/">https://coredns.io/</a>).</p>
<h3 id="pods-its-just-a-sandbox-for-hosting-containers">Pods (it’s just a sandbox for hosting containers.)</h3>
<p>In the VMware world, the atomic unit of scheduling is the virtual machine (VM). In the Docker world, it’s the container. Well… in the Kubernetes world, it’s the Pod. The simplest model is to run a single container per Pod. However, there are advanced use-cases that run multiple containers inside a single Pod. <code>An infrastructure-centric use-case for multi-container Pods is a service mesh.</code></p>
<p><strong>Pod lifecycle</strong></p>
<p>Pods are mortal. They’re created, they live, and they die. If they die unexpectedly, you don’t bring them back to life. Instead, Kubernetes starts a new one in its place</p>
<p><strong>How do we deploy Pods</strong></p>
<p>To deploy a Pod to a Kubernetes cluster you define it in a manifest file and POST that manifest file to the API Server. The control plane verifies the configuration of the YAML file, writes it to the cluster store as a record of intent, and the scheduler deploys it to a healthy node with enough available resources. This process is identical for single-container Pods and multi-container Pods.</p>
<p>We can also run the Pod directly mention the docker image <code>kubctl run podName --image=nignix:alpline</code></p>
<p><strong>Pods and cgroups</strong></p>
<p>At a high level, Control Groups (cgroups) are a Linux kernel technology that prevents individual containers from consuming all of the available CPU, RAM and IOPS on a node. You could say that cgroups actively police resource usage.Individual containers have their own cgroup limits.</p>
<p><strong>Pod manifest files</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">zone</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-ctr</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nigelpoulton/k8sbook:latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>The .apiVersion field tells you two things – the API group and the API version.</li>
<li>.kind field tells Kubernetes the type of object is being deployed.</li>
<li>.metadata section is where you attach a name and labels These help you identify the object in the cluster, as well as create loose couplings between different objects. You can also define the Namespace that an object should be deployed to. Keeping things brief, <code>Namespaces are a way to logically divide a cluster into multiple virtual clusters for management purposes.</code> In the real world, it’s highly recommended to use namespaces, however, you should not think of them as strong security boundaries.</li>
<li>The .spec section is where you define the containers that will run in the Pod.</li>
<li><code>kubectl apply -f pod.yml</code> →command to POST the manifest to the API server.</li>
<li><code>kubectl get pods</code> →command to check the status.</li>
<li><code>kubectl get pods hello-pod -o yaml</code> → To get more details about pod</li>
<li><code>kubectl describe pods hello-pod</code> →This provides a nicely formatted multi-line overview of an object. It even includes some important object lifecycle events.</li>
<li><code>kubectlexec -it hello-pod --sh</code> →command will log-in to the first container</li>
</ul>
<h3 id="replicaset">ReplicaSet</h3>
<p>To deploy multiple instance. A ReplicaSet is defined with fields, including a selector that specifies how to identify Pods it can acquire, a number of replicas indicating how many Pods it should be maintaining, and a pod template specifying the data of new Pods it should create to meet the number of replicas criteria. A ReplicaSet then fulfills its purpose by creating and deleting Pods as needed to reach the desired number. When a ReplicaSet needs to create new Pods, it uses its Pod template.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="nx">apiVersion</span><span class="o">:</span> <span class="nx">apps</span><span class="o">/</span><span class="nx">v1</span>
</span></span><span class="line"><span class="cl"><span class="nx">kind</span><span class="o">:</span> <span class="nx">ReplicaSet</span>
</span></span><span class="line"><span class="cl"><span class="nx">metadata</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span><span class="o">:</span> <span class="nx">frontend</span>
</span></span><span class="line"><span class="cl"><span class="nx">labels</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="nx">app</span><span class="o">:</span> <span class="nx">guestbook</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tier</span><span class="o">:</span> <span class="nx">frontend</span>
</span></span><span class="line"><span class="cl"><span class="nx">spec</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="nx">replicas</span><span class="o">:</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="nx">selector</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="nx">matchLabels</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tier</span><span class="o">:</span> <span class="nx">frontend</span>
</span></span><span class="line"><span class="cl"><span class="nx">template</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="nx">metadata</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">labels</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">tier</span><span class="o">:</span> <span class="nx">frontend</span>
</span></span><span class="line"><span class="cl">  <span class="nx">spec</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">containers</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">-</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">php</span><span class="o">-</span><span class="nx">redis</span>
</span></span><span class="line"><span class="cl">      <span class="nx">image</span><span class="o">:</span> <span class="nx">gcr</span><span class="p">.</span><span class="nx">io</span><span class="o">/</span><span class="nx">google_samples</span><span class="o">/</span><span class="nx">gb</span><span class="o">-</span><span class="nx">frontend</span><span class="o">:</span><span class="nx">v3</span>
</span></span></code></pre></div><p><strong>Deployments vs ReplicaSet</strong></p>
<p>Deployment is a higher-level concept that manages ReplicaSets and provides declarative updates to Pods along with a lot of other useful features. Therefore, we recommend using Deployments instead of directly using ReplicaSets</p>
<p>CMD</p>
<ol>
<li><code>kubectl get rs</code> → get all replica</li>
</ol>
<h3 id="deployments">Deployments</h3>
<p>Deploy Pods indirectly via a higher-level controller. Examples of higher-level controllers include; Deployments, DaemonSets, and StatefulSets.</p>
<p>For example, a Deployment is a higher-level Kubernetes object that wraps around a particular Pod and adds features such as scaling, zero-downtime updates, and versioned rollbacks.</p>
<p>Behind the scenes, Deployments, DaemonSets and StatefulSets implement a controller and a watch loop that is constantly observing the cluster making sure that current state matches desired state.</p>
<p><strong>Difference between pod and Deployments</strong></p>
<p>Pods don’t self-heal, they don’t scale, and they don’t allow for easy updates or rollbacks. Deployments do all of these. As a result, you’ll almost always deploy Pods via a Deployment controller.</p>
<p><code>Desired state</code> is what you want. Current state is what you have. If the two match, everybody’s happy.</p>
<p><code>The declarative model</code> is a way of telling Kubernetes what your desired state is, without having to get into the detail of how to implement it. You leave the how up to Kubernetes.</p>
<p><strong>Reconciliation loops</strong></p>
<p>Fundamental to desired state is the concept of background reconciliation loops (a.k.a. control loops). For example, ReplicaSets implement a background reconciliation loop that is constantly checking whether the right number of Pod replicas are present on the cluster. If there aren’t enough, it adds more. If there are too many, it terminates some. To be crystal clear, Kubernetes is constantly making sure that current state matches desired state.</p>
<p><strong>Rolling updates with Deployments</strong></p>
<p>Now, assume you’ve experienced a bug, and you need to deploy an updated image that implements a fix. To do this, you update the same Deployment YAML file with the new image version and re-POST it to the API server. This registers a new desired state on the cluster, requesting the same number of Pods, but all running the new version of the image. To make this happen, Kubernetes creates a new ReplicaSet for the Pods with the new image.You now have two ReplicaSets – the original one for the Pods with the old version of the image, and a new one for the Pods with the updated version. Each time Kubernetes increases the number of Pods in the new ReplicaSet (with the new version of the image) it decreases the number of Pods in the old ReplicaSet (with the old versionof the image). Net result, you get a smooth rolling update with zero downtime.</p>
<p><strong>Deployments manifest files</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w"> </span><span class="c">#Older versions of k8s use apps/v1beta1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-deploy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hello-world</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">minReadySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">strategy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">RollingUpdate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">rollingUpdate</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">maxUnavailable</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">maxSurge</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hello-world</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nigelpoulton/k8sbook:latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>The .spec</code> section is where most of the action happens. Anything directly below .spec relates to the Pod. Anything nested below</li>
<li><code>.spec.template</code> relates to the Pod template that the Deployment will manage. In this example, the Pod template defines a single container.</li>
<li><code>.spec.replicas</code> tells Kubernetes how may Pod replicas to deploy</li>
<li><code>.spec.selector</code> is a list of labels that Pods must have in order for the Deployment to manage them.</li>
<li><code>.spec.strategy</code> tells Kubernetes how to perform updatesto the Pods managed by the Deployment.Update using the RollingUpdate strategy
<ul>
<li>Never have more than one Pod below desired state ( maxUnavailable: 1 )</li>
<li>Never have more than one Pod above desired state ( maxSurge: 1 )</li>
</ul>
</li>
<li><code>.spec.minReadySeconds</code> This is set to 10 , telling Kubernetes to wait for 10 seconds between each Pod being updated.(on new deployment)</li>
<li><code>kubectl apply -f deploy.yml</code> → will send the yml to API server to deploy</li>
<li><code>kubectl get deploy hello-deploy</code></li>
</ul>
<h3 id="services">Services</h3>
<p>When newly pods created are scaled it will have new IP so if we have other pod communicating with it. it is unrealible.This is where Services come in to play. Services provide reliable networking for a set of Pods.</p>
<p>They operate at the TCP and UDP layer, Services do not possess application intelligence and cannot provide application-layer host and path routing. For that, you need an Ingress, which understands HTTP and provides host and path-based routing.</p>
<p>Services use labels and a label selector to know which set of Pods to load-balance traffic to. The Service has a label selector that is a list of all the labels a Pod must possess in order for it to receive traffic from the Service.</p>
<p><strong>Endpoint Objects</strong></p>
<p>Kubernetes is constantly evaluating the Service’s label selector against the current list of healthy Pods on the cluster. Any new Pods that match the selector get added to the <code>Endpoints object</code>, and any Pods that disappear get removed. This means the Endpoints object is always up to date. Then, when a Service is sending traffic to Pods, it queries its Endpoints object for the latest list of healthy matching Pods. Every Service gets its own Endpoints object with the same name as the Service.This object holds a list of all the Pods the Service matches and is dynamically updated as matching Pods come and go.</p>
<p>Types</p>
<ul>
<li>
<p>ClusterIP [default]</p>
<ul>
<li>has a stable IP address and port that is only accessible from inside the cluster</li>
<li>Creating a new Service called “magic-sandbox” will trigger the following. Kubernetes will register the name“magic-sandbox”, along with the ClusterIP and port, with the <code>cluster’s DNS service</code>. The name, ClusterIP, and port are guaranteed to be long-lived and stable, and all Pods in the cluster send service discovery requests to the internal DNS and will therefore be able to resolve “magic-sandbox” to the ClusterIP. IPTABLES or IPVS rules are distributed across the cluster that ensure traffic sent to the ClusterIP gets routed to Pods on the backend</li>
</ul>
</li>
<li>
<p>Headless service → To directly communicate with master not with replica</p>
</li>
<li>
<p>NodePort service →This builds on top of ClusterIP and enables access from outside of the cluster.[static ip]</p>
<ul>
<li>
<p>Port range can be only between 30000 to 32767</p>
</li>
<li>
<p>Image</p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/e64b9889-d141-4df9-87a5-acae52ef24ab/57e57957-a7ea-4ca7-843b-96cc3bcb5836/Untitled.png" alt="Untitled"></p>
</li>
</ul>
</li>
<li>
<p>Loadbalancer</p>
</li>
</ul>
<p><strong>Service YAML</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-svc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span>- <span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w"> </span><span class="c">#the port the service need to be listen</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w"> </span><span class="c"># the port the app is running</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hello-world</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c"># Label selector</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c"># Service is looking for Pods with the label `app=hello-world` can be any key and vaule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">deploy.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-deploy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hello-world</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hello-world</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="c"># Pod labels</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="c"># The label matches the Service&#39;s label selector</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello-ctr</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>the Service has a label selector ( <code>.spec.selector</code> ) with a single value app=hello-world . This is the label that the Service is looking for when it queries the cluster for matching Pods.</li>
<li>The Deployment specifies a Pod template with the same app=hello-world label ( <code>.spec.template.metadata.labels</code> )</li>
<li>the Service will select all 10 Pod replicas and provide them with a stable networking endpoint and load-balance traffic to them.</li>
<li><code>kubectl get services</code> → Will list all service with IP get the IP from here</li>
</ul>
<p><strong>How to use service</strong></p>
<p>To connect with service user the service name or ip by <code>kubectl get services</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="nx">Redis</span><span class="p">(</span><span class="nx">host</span><span class="o">=</span><span class="s2">&#34;servicename&#34;</span><span class="p">,</span><span class="nx">port</span><span class="o">=</span><span class="s2">&#34;8080&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p><strong>Service discovery</strong></p>
<p>There are two major components to service discovery:</p>
<ul>
<li>Service registration</li>
<li>Service discovery</li>
</ul>
<p><strong>Ingress</strong></p>
<p>CMD</p>
<ul>
<li><code>kubectl get pod -o wide</code> → will display the IP</li>
<li><code>kubectl apply -f svc.yml</code> →Tells Kubernetes to deploy a new object from a file called svc.yml . The .kind field in the YAML file tells Kubernetes that you’re deploying a new Service object.</li>
<li><code>kubectl get svc hello-svc</code> →Introspecting Services display the IP</li>
<li><code>kubectl get ep hello-svc</code> →the Endpoint controller’s</li>
</ul>
<h3 id="service-monitor">Service Monitor</h3>
<h3 id="kubernetes-storage">Kubernetes storage</h3>
<p>When we restart the pod the data stored in pod will go to solve this we using Kubernetes storage</p>
<p><strong>Storage for single pod</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">local-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">local-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">local-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">local-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">local -&gt; label must need to match with voulme</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/usr/share/nginx/html</span><span class="w"> </span><span class="c">#Path inside the container</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/var/nginxserver</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>When we store data in <code>/usr/share/nginx/html</code> in this dir it will be stored in <code>/var/nginxserver</code> this kind of storage cannot be shared among the pod and nodes</li>
</ul>
<p><strong>Shared storage</strong></p>
<p>The three main resources in the persistent volume subsystem are:</p>
<ul>
<li>Persistent Volumes (PV)</li>
<li>Storage Classes (SC) → Type of storage class ex NFS,AWS,azure..etc</li>
<li>Persistent Volume Claims (PVC) → used to claim the storage that was alloacted using PV</li>
</ul>
<ol>
<li>
<p>First create PV with following</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolume</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nfs</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">capacity</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">500Mi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">persistentVolumeReclaimPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Retain</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	    </span>- <span class="l">ReadWriteMany </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">storageClassName</span><span class="p">:</span><span class="w"> </span><span class="l">nfs</span><span class="w"> </span><span class="c">#type of storage that we using</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nfs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="m">192.168.1.7</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/srv/nfs&#34;</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>.spec.accessModes</code> defines how the PV can be mounted. Three options exist:
<ul>
<li>ReadWriteOnce (RWO)</li>
<li>ReadWriteMany (RWM)</li>
<li>ReadOnlyMany(ROM)</li>
<li><strong>ReadWriteOnce</strong> defines a PV that can only be mounted/bound as R/W by a single PVC. Attempts from multiple PVCs to bind (claim) it will fail.</li>
<li><strong>ReadWriteMany</strong> defines a PV that can be bound as R/W by multiple PVCs. This mode is usually only supported by file and object storage such as NFS. Block storage usually only supports RWO .</li>
<li><strong>ReadOnlyMany</strong> defines a PV that can be bound by multiple PVCs as R/O. A couple of things are worth noting. First up, a PV can only be opened</li>
</ul>
</li>
<li><code>persistentVolumeReclaimPolicy</code> This tells Kubernetes what to do with a PV when its PVC has been released. Two policies currently exist:
<ul>
<li>Delete →This policy deletes the PV and associated storage resource on the external storage system</li>
<li>Retain</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Deploy the PV by kubctl -f apply filename.yml</p>
<ul>
<li><strong>kubctl get pv</strong> &gt; to get all PV</li>
<li>PV are not bound to namespace it can be accesed by any namspace</li>
</ul>
</li>
<li>
<p>Create PVC to claim the pV</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolumeClaim</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mycustomvolume</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">ReadWriteMany</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">storageClassName</span><span class="p">:</span><span class="w"> </span><span class="l">nfs</span><span class="w"> </span><span class="c">#we can create custom storage class </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">100Mi4</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>.spec</code> section must match with the PV you are binding it with. In this example, access modes, storage class, and capacity must match with the PV. but the storage can be less then what we give in <code>PV</code></li>
<li>It bound to namespace</li>
<li><code>kubctl describe pvc</code> → to describe what’ going on helpfull to debug.</li>
</ul>
</li>
<li>
<p>Use it in deployment</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nfs-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nfs-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nfs-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nfs-web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nfs</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/usr/share/nginx/html</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mycustomvolume</span><span class="w"> </span><span class="c">#Label need to match</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">persistentVolumeClaim</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">claimName</span><span class="p">:</span><span class="w"> </span><span class="l">nfs</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<h3 id="config-maps">Config Maps</h3>
<p>Kubernetes provides an object called a ConfigMap (CM) that lets you store configuration data outside of a Pod. It also lets you dynamically inject the data into a Pod at run-time. ConfigMaps are a map of key/value pairs and we call each key/value pair an entry.</p>
<p><strong>Example</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c">#multimap.yml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">multimap</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">DB_URL</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">.env </span><span class="p">:</span><span class="w"> </span><span class="l">|</span><span class="w"> </span><span class="c"># these content stored in file name called .env on pod </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="l">env = plex-test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="l">endpoint = 0.0.0.0:31001</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="l">char = utf8</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="l">vault = PLEX/test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="l">log-size = 512M</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>kubectl apply -f multimap.yml</code></li>
<li>Use Pipe (|) to create a file</li>
</ul>
<p><strong>Injecting ConfigMap data into Pods and containers</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dapi-test-pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">test-container</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">registry.k8s.io/busybox</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&#34;/bin/sh&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;-c&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;env&#34;</span><span class="w"> </span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># Define the environment variable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">SPECIAL_LEVEL_KEY</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">valueFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">configMapKeyRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c"># The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">multimap</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="c"># Specify the key associated with the value</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">DB_URL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span></code></pre></div><p><strong>ConfigMaps and volumes</strong></p>
<p>Using ConfigMaps with volumes is the most flexible option. You can reference entire configuration files as well as make updates to the ConfigMap and have them reflected in running containers.</p>
<ol>
<li>Create the ConfigMap</li>
<li>Create a ConfigMap volume in the Pod template</li>
<li>Mount the ConfigMap volume into the container</li>
<li>Entries in the ConfigMap will appear in the container as individual files</li>
</ol>
<h3 id="secretes">Secretes</h3>
<p>Secrets can be created independently of the Pods that use them, there is less risk of the Secret (and its data) being exposed during the workflow of creating, viewing, and editing Pods. Kubernetes, and applications that run in your cluster, can also take additional precautions with Secrets, such as avoiding writing sensitive data to nonvolatile storage.</p>
<p>Kubernetes Secrets are, by default, stored unencrypted in the API server&rsquo;s underlying data store (etcd). Anyone with <code>API access can retrieve or modify a Secret, and so can anyone with access to etcd</code>. Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read any Secret in that namespace; this includes indirect access such as the ability to create a Deployment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dotfile-secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">.secret-file</span><span class="p">:</span><span class="w"> </span><span class="l">dmFsdWUtMg0KDQo=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">secret-dotfiles-pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">secret-volume</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">secret</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">dotfile-secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dotfile-test-container</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">registry.k8s.io/busybox</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="l">ls</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;-l&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;/etc/secret-volume&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">secret-volume</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">readOnly</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/etc/secret-volume&#34;</span><span class="w">
</span></span></span></code></pre></div><h3 id="statefulsets">StatefulSets</h3>
<p>StatefulSets in Kubernetes are a resource type used to manage stateful applications, particularly those that require unique identities, stable network identifiers, and stable persistent storage. They are used for applications like databases where each instance needs a specific identity and state.</p>
<h3 id="without-statefulsets">Without StatefulSets</h3>
<p>Without StatefulSets, deploying MongoDB in Kubernetes might lead to challenges:</p>
<ul>
<li><strong>Pod Identity:</strong> Pods get random names, and their identities might change upon restarts or rescheduling. MongoDB instances require consistent and predictable identities for proper replication setup and cluster coordination.</li>
<li><strong>Storage:</strong> MongoDB needs persistent storage for its data files. Without StatefulSets, ensuring each pod has its own persistent volume becomes complex. If a pod is rescheduled or fails, data integrity can be compromised.</li>
</ul>
<h3 id="with-statefulsets">With StatefulSets</h3>
<p>Using StatefulSets for MongoDB:</p>
<ul>
<li><strong>Pod Identity:</strong> StatefulSets assign stable, predictable identities (like <strong><code>mongo-0</code></strong>, <strong><code>mongo-1</code></strong>, etc.) to each MongoDB instance. This ensures consistency and stability crucial for proper replication and cluster coordination.</li>
<li><strong>Storage:</strong> StatefulSets facilitate the use of persistent volumes, ensuring that each MongoDB instance has its dedicated and persistent storage. Even if a pod fails or needs to be rescheduled, the data remains intact and can be reattached to a new pod with the same identity.</li>
</ul>
<p><strong>StatefulSet Pod naming</strong></p>
<p>All Pods managed by a StatefulSet get predictable and persistent names. These names are vital, and are at the core of how Pods are started, self-healed, scaled, deleted, attached to volumes, and more. The format of StatefulSet Pod names is <StatefulSetName>-<Integer> . The integer is a zero-based index ordinal, which is just a fancy way of saying “number starting from 0”</p>
<p><strong>Ordered creation and deletion</strong></p>
<p>StatefulSets create one Pod at a time, and always wait for previous Pods to be running and ready before creating the next. This is different from Deployments that use a ReplicaSet controller to start all Pods at the same time,causing potential race conditions.</p>
<p><strong>Deleting StatefulSets</strong></p>
<p>Firstly, deleting a StatefulSet does not terminate Pods in order. With this in mind, you may want to scale a StatefulSet to 0 replicas before deleting it. You can also use terminationGracePeriodSeconds to further control the way Pods are terminated. It’s common to set this to at least 10 seconds to give applications running in Pods a chance to flush local buffers and safely commit any writes that are still in-flight.</p>
<h3 id="kubectl">Kubectl</h3>
<p>Kubectl is the main Kubernetes command-line tool and is what you will use for your day-to-day Kubernetes management activities.</p>
<p>kubectl configuration file is called config and lives in $HOME/.kube . It contains definitions for:</p>
<p>• Clusters • Users (credentials) • Contexts</p>
<p><strong>Clusters</strong> is a list of clusters that kubectl knows about and is ideal if you plan on using a single workstation to manage multiple clusters. Each cluster definition has a name, certificate info, and API server endpoint.</p>
<p><strong>Users</strong> let you define different users that might have different levels of permissions on each cluster. For example, you might have a dev user and an ops user, each with different permissions. Each user definition has a friendly name, a username, and a set of credentials.</p>
<p><strong>Contexts</strong> bring together clusters and users under a friendly name. For example, you might have a context called deploy-prod that combines the deploy user credentials with the prod cluster definition. If you use kubectl with this context you will be POSTing commands to the API server of the prod cluster as the deploy user.</p>
<h3 id="resources">Resources</h3>
<ol>
<li><a href="https://youtu.be/s_o8dwzRlu4">Give a idea about and overview of the architecture of that</a></li>
<li><a href="https://youtu.be/ZuIQurh_kDk">Design principle</a></li>
<li><a href="https://dev.to/leandronsp/kubernetes-101-part-i-the-fundamentals-23a1">https://dev.to/leandronsp/kubernetes-101-part-i-the-fundamentals-23a1</a></li>
<li><a href="https://dev.to/mattiasfjellstrom/kubernetes-101-pods-part-1-mn2">kubernetes 101 series</a></li>
<li><a href="https://github.com/jatrost/awesome-kubernetes-threat-detection">https://github.com/jatrost/awesome-kubernetes-threat-detection</a></li>
<li><a href="https://openai.com/research/scaling-kubernetes-to-7500-nodes">https://openai.com/research/scaling-kubernetes-to-7500-nodes</a></li>
<li><a href="https://github.blog/2019-11-21-debugging-network-stalls-on-kubernetes/">https://github.blog/2019-11-21-debugging-network-stalls-on-kubernetes/</a></li>
<li><a href="https://iximiuz.ck.page/posts/ivan-on-containers-kubernetes-and-backend-development">https://iximiuz.ck.page/posts/ivan-on-containers-kubernetes-and-backend-development</a></li>
<li><a href="https://dev.to/therubberduckiee/explaining-kubernetes-to-my-uber-driver-4f60">https://dev.to/therubberduckiee/explaining-kubernetes-to-my-uber-driver-4f60</a></li>
<li><strong><a href="https://aws.plainenglish.io/kubectl-get-kubernetes-o-architecture-6d4bd97dcaaf">kubernetes -o architecture</a></strong></li>
<li><a href="https://towardsdev.com/understanding-control-pane-and-nodes-in-k8s-architecture-5572018f7624">https://towardsdev.com/understanding-control-pane-and-nodes-in-k8s-architecture-5572018f7624</a></li>
</ol>
<h3 id="products">Products</h3>
<ol>
<li><a href="https://cast.ai/">To cut down the cost of kubernetes</a></li>
<li><strong><a href="https://www.civo.com/">The first cloud native service provider powered only by Kubernetes</a></strong></li>
</ol>

            </div>
        </article></main>
</div>
<footer class="footer">
    <span class="footer_item"> </span>
    &nbsp;

    <div class="footer_social-icons">
<a href="https://github.com/programmerraja" target="_blank" rel="noopener noreferrer me"
    title="Github">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
</a>
<a href="https://twitter.com/programmerraja" target="_blank" rel="noopener noreferrer me"
    title="Twitter">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z">
    </path>
</svg>
</a>
<a href="https://www.linkedin.com/in/programmerraja/" target="_blank" rel="noopener noreferrer me"
    title="Linkedin">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
    <rect x="2" y="9" width="4" height="12"></rect>
    <circle cx="4" cy="4" r="2"></circle>
</svg>
</a>
<a href="index.xml" target="_blank" rel="noopener noreferrer me"
    title="Rss">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9" />
    <path d="M4 4a16 16 0 0 1 16 16" />
    <circle cx="5" cy="19" r="1" />
</svg>
</a>
</div>
    <small class="footer_copyright">
        © 2024 K.Boopathi.
        
    </small>
</footer><a href="#" title="" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    






    
    <script src="https://programmerraja.github.io/blog/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js" integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30&#43;lSNuSkl4QXuNyy8="></script>

    

</body>
</html>
